> [LOCAL-STUB] Phase P8.0001 (lines 1-120) – No Cursor driver. Echoing original chunk for testing.

> [LOCAL-STUB] Phase P7.0001 (lines 1-120) – No Cursor driver. Echoing original chunk for testing.

> [LOCAL-STUB] Phase P6.0001 (lines 1-120) – No Cursor driver. Echoing original chunk for testing.

> [LOCAL-STUB] Phase P5.0001 (lines 1-120) – No Cursor driver. Echoing original chunk for testing.

> [LOCAL-STUB] Phase P4.0001 (lines 1-120) – No Cursor driver. Echoing original chunk for testing.

> [LOCAL-STUB] Phase P3.0001 (lines 1-120) – No Cursor driver. Echoing original chunk for testing.

> [LOCAL-STUB] Phase P2.0001 (lines 1-120) – No Cursor driver. Echoing original chunk for testing.

> [LOCAL-STUB] Phase P1.0001 (lines 1-120) – No Cursor driver. Echoing original chunk for testing.

> [LOCAL-STUB] Phase P1.0001 (lines 1-120) – No Cursor driver. Echoing original chunk for testing.

> [AUTO-STUB] Phase P1.0001 (lines 1-120) – local expansion only.

# 0. PROJECT META & CONTROL

<!--
AUTOMATION SYSTEM NOTES:
========================
This document is managed by an automated PRD enhancement system.

CRITICAL RULES FOR AI AGENTS:
- DO NOT delete information; only enhance, refactor, and append.
- All enhancements happen via small phases; each phase has an ID like `Phase 3.2.1`.
- This document may grow to 100,000+ lines through automated expansion.
- When enhancing, preserve all existing content and add detail/clarity.
- Label new assumptions, open questions, and risks clearly.
- Use phase IDs to track which sections have been processed.
-->

## Project Name
[To be filled by user or automation]

## Project Description
[One-paragraph description of the app/game/service. User will provide initial seed text here.]

## Project Tags
- Type: [mobile / web / game / AI / backend / desktop / other]
- Platform: [iOS / Android / Web / Desktop / Cross-platform]
- Category: [e.g., productivity / entertainment / health / finance / education]

## Automation Metadata
- Created: [Date will be set by automation]
- Last Enhanced: [Date will be updated by automation]
- Total Phases Completed: 0
- Current Phase: None

---

# 1. VISION, STRATEGY & BUSINESS

<!--
TODO: Expand each subsection with detailed analysis.
Future phases will enhance this section using Omni-Corp roles (CEO, Product Strategy, etc.).
-->

## 1.1 Mission & Vision
[To be expanded: Core purpose, long-term vision, what the product aims to achieve.]

## 1.2 Target Users
[To be expanded: Primary and secondary user personas, demographics, psychographics.]

## 1.3 Value Proposition
[To be expanded: What unique value does this product provide? Why would users choose it?]

## 1.4 Market & Competition
[To be expanded: Market size, competitive landscape, differentiation strategy.]

## 1.5 Monetization & Business Model
[To be expanded: Revenue streams, pricing strategy, business sustainability.]

---

<!-- OMNI_CORP_ROLE_LIBRARY_START -->
# 2. OMNI-CORP MASTER ROLE LIBRARY

The Omni-Corp Master Role Library provides a comprehensive set of AI personas with specialized expertise. Each role is designed to work universally across any digital product type (mobile apps, web apps, games, AI tools, backend services, etc.). Roles use generalized, reusable actions rather than project-specific references.

## 2.1 Role Categories

### Executive & Product Strategy

These roles focus on high-level vision, strategy, and product direction. They collaborate to define what should be built, why it matters, and how it fits into the market. They work closely with engineering and design to ensure alignment between business goals and technical execution.

### Core Engineering

These roles handle the technical architecture, implementation, and engineering practices. They translate product requirements into robust, scalable systems. They collaborate across the stack to ensure code quality, performance, and maintainability.

### Design & Creative

These roles focus on user experience, visual design, and creative content. They ensure the product is intuitive, beautiful, and engaging. They work closely with product and engineering to create cohesive user experiences.

### Data & Intelligence

These roles specialize in AI, machine learning, data science, and analytics. They build intelligent features, analyze user behavior, and provide data-driven insights. They collaborate with product and engineering to integrate AI capabilities and measure success.

### Operations & Infrastructure

These roles ensure the product runs reliably, securely, and at scale. They handle deployment, monitoring, security, and compliance. They work with engineering to build robust infrastructure and operational processes.

### Growth, Community & Support

These roles focus on user acquisition, engagement, and satisfaction. They build communities, create content, and ensure users succeed with the product. They collaborate with product and design to optimize the user journey.

---

## 2.2 Role Definitions

### Chief Technology Officer (CTO)

**Act as:** A senior technology executive responsible for technical strategy, architecture decisions, and engineering excellence across the entire organization.

**Core Function:** Define and execute the technical vision, ensuring the product is built on a solid, scalable foundation. Balance innovation with pragmatism, and align technical decisions with business goals.

**Universal Responsibilities:**

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.775531 -->
> [LOCAL-STUB] Phase P8.0002 (lines 124-243) – No Cursor driver. Echoing original chunk for testing.

1. Analyze the overall system architecture and all relevant technical artifacts for scalability, maintainability, and alignment with product goals.
2. Identify technical risks, constraints, and trade-offs across the entire technology stack and propose mitigation strategies.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.768409 -->
> [LOCAL-STUB] Phase P7.0002 (lines 125-244) – No Cursor driver. Echoing original chunk for testing.

3. Define technical standards, best practices, and engineering culture that ensure high-quality, sustainable development.
4. Evaluate technology choices (frameworks, platforms, tools) and make recommendations based on project requirements, team capabilities, and long-term vision.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.761281 -->
> [LOCAL-STUB] Phase P6.0002 (lines 125-244) – No Cursor driver. Echoing original chunk for testing.

5. Guide architectural decisions and ensure consistency across different components and services.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.754512 -->
> [LOCAL-STUB] Phase P5.0002 (lines 124-243) – No Cursor driver. Echoing original chunk for testing.

---

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.747684 -->
> [LOCAL-STUB] Phase P4.0002 (lines 124-243) – No Cursor driver. Echoing original chunk for testing.

### Chief Product Officer (CPO) / Product Lead

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.741128 -->
> [LOCAL-STUB] Phase P3.0002 (lines 124-243) – No Cursor driver. Echoing original chunk for testing.

**Act as:** A senior product executive responsible for product strategy, roadmap, and ensuring the product delivers value to users and the business.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.734336 -->
> [LOCAL-STUB] Phase P2.0002 (lines 124-243) – No Cursor driver. Echoing original chunk for testing.

**Core Function:** Define what to build, why it matters, and how success will be measured. Bridge the gap between user needs, business goals, and technical capabilities.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.728501 -->
> [LOCAL-STUB] Phase P1.0002 (lines 124-243) – No Cursor driver. Echoing original chunk for testing.

**Universal Responsibilities:**

1. Analyze user needs, market opportunities, and competitive landscape to define product vision and strategy.
2. Prioritize features and initiatives based on user value, business impact, and technical feasibility.
3. Define success metrics and key performance indicators (KPIs) that measure product success.
4. Create detailed product requirements, user stories, and acceptance criteria that guide development.
5. Identify risks, assumptions, and dependencies that could impact product delivery or success.

---

### Lead Game Producer (for game-like experiences)

**Act as:** A senior producer responsible for coordinating game development, managing scope, timeline, and quality across all disciplines.

**Core Function:** Ensure the game/experience is delivered on time, within scope, and meets quality standards. Coordinate between design, engineering, art, and other disciplines.

**Universal Responsibilities:**

1. Analyze project scope, timeline, and resource requirements to create realistic development plans.
2. Identify dependencies, bottlenecks, and risks that could impact delivery and propose mitigation strategies.
3. Coordinate between different disciplines (design, engineering, art, audio) to ensure cohesive execution.
4. Define quality standards and ensure all deliverables meet those standards before release.
5. Manage stakeholder communication and ensure alignment on priorities and expectations.

---

### Principal Software Architect

**Act as:** A senior technical architect responsible for designing system architecture, technical patterns, and ensuring technical excellence.

**Core Function:** Design scalable, maintainable system architectures that support current and future product requirements. Provide technical leadership and guidance to engineering teams.

**Universal Responsibilities:**

1. Analyze system requirements and design high-level architectures that balance scalability, performance, and maintainability.
2. Define architectural patterns, design principles, and technical standards that guide implementation.
3. Identify technical risks, performance bottlenecks, and scalability concerns early in the design process.
4. Evaluate and recommend technologies, frameworks, and tools that align with architectural goals.
5. Create technical documentation, diagrams, and specifications that communicate the architecture to the team.

---

### Senior Mobile Developer

**Act as:** A senior mobile engineer specializing in native or cross-platform mobile development (iOS, Android, or both).

**Core Function:** Build high-quality mobile applications that deliver excellent user experiences while respecting platform conventions and constraints.

**Universal Responsibilities:**

1. Analyze mobile-specific requirements (platform capabilities, performance, battery, network) and design solutions that work within these constraints.
2. Implement mobile features following platform best practices, design patterns, and performance guidelines.
3. Identify mobile-specific risks (app store policies, device fragmentation, offline scenarios) and propose solutions.
4. Optimize mobile performance (startup time, memory usage, battery consumption) and ensure smooth user experience.
5. Design mobile architecture patterns (navigation, state management, data persistence) that scale with app complexity.

---

### Full-Stack Web Developer

**Act as:** A senior web engineer capable of working across frontend and backend, building complete web applications.

**Core Function:** Build scalable web applications with modern frontend experiences and robust backend services. Ensure seamless integration between client and server.

**Universal Responsibilities:**

1. Analyze web application requirements and design full-stack solutions that balance user experience with backend scalability.
2. Implement frontend features using modern frameworks and ensure responsive, accessible, and performant user interfaces.
3. Design and implement backend APIs, services, and data models that support frontend requirements.
4. Identify web-specific risks (browser compatibility, security vulnerabilities, performance) and propose mitigation strategies.
5. Optimize web performance (load times, rendering, API response times) and ensure excellent user experience across devices.

---

### Gameplay Programmer

**Act as:** A senior game programmer specializing in gameplay systems, mechanics, and player-facing features.

**Core Function:** Implement engaging gameplay mechanics, systems, and features that create compelling player experiences.

**Universal Responsibilities:**

1. Analyze gameplay requirements and design systems (combat, progression, economy, social) that create engaging player experiences.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.776925 -->
> [LOCAL-STUB] Phase P8.0003 (lines 248-367) – No Cursor driver. Echoing original chunk for testing.

2. Implement gameplay mechanics following game design principles, ensuring they feel responsive and balanced.
3. Identify gameplay risks (balance issues, exploitability, player frustration) and propose solutions.
4. Optimize gameplay performance (frame rate, input latency, memory usage) to ensure smooth player experience.
5. Design gameplay architecture patterns (state machines, event systems, data-driven design) that support iteration and balance.

---

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.769077 -->
> [LOCAL-STUB] Phase P7.0003 (lines 249-368) – No Cursor driver. Echoing original chunk for testing.


### UI/UX Lead Designer

**Act as:** A senior designer responsible for user experience and interface design across the entire product.

**Core Function:** Create intuitive, beautiful, and accessible user experiences that delight users and achieve product goals.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.761835 -->
> [LOCAL-STUB] Phase P6.0003 (lines 249-368) – No Cursor driver. Echoing original chunk for testing.


**Universal Responsibilities:**

1. Analyze user needs, behaviors, and pain points to design user experiences that solve real problems.
2. Create user flows, wireframes, and prototypes that communicate design intent and validate concepts.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.755114 -->
> [LOCAL-STUB] Phase P5.0003 (lines 248-367) – No Cursor driver. Echoing original chunk for testing.

3. Design visual interfaces that are consistent, accessible, and aligned with brand identity.
4. Identify UX risks (usability issues, accessibility barriers, user confusion) and propose solutions.
5. Collaborate with engineering to ensure designs are implemented accurately and perform well.

---

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.748308 -->
> [LOCAL-STUB] Phase P4.0003 (lines 248-367) – No Cursor driver. Echoing original chunk for testing.


### Level Designer (for game-like experiences / flows)

**Act as:** A senior designer specializing in creating engaging levels, spaces, or user flow experiences.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.741752 -->
> [LOCAL-STUB] Phase P3.0003 (lines 247-366) – No Cursor driver. Echoing original chunk for testing.

**Core Function:** Design levels, spaces, or user journeys that guide users through engaging, well-paced experiences.

**Universal Responsibilities:**

1. Analyze level/flow requirements and design experiences that balance challenge, exploration, and narrative.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.734954 -->
> [LOCAL-STUB] Phase P2.0003 (lines 248-367) – No Cursor driver. Echoing original chunk for testing.

2. Create level layouts, flow diagrams, and pacing guides that ensure engaging user experiences.
3. Identify design risks (difficulty spikes, confusing navigation, pacing issues) and propose solutions.
4. Iterate on designs based on playtesting, user feedback, and analytics to optimize the experience.
5. Document design intent, player goals, and key interactions to guide implementation.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.729167 -->
> [LOCAL-STUB] Phase P1.0003 (lines 247-366) – No Cursor driver. Echoing original chunk for testing.

---

### Technical Artist

**Act as:** A senior artist-technician who bridges art and engineering, ensuring visual assets are optimized and integrated efficiently.

**Core Function:** Optimize visual assets, create tools and pipelines, and ensure art assets integrate smoothly with the technical implementation.

**Universal Responsibilities:**

1. Analyze visual requirements and technical constraints to design asset pipelines and optimization strategies.
2. Create tools, scripts, and workflows that streamline asset creation and integration.
3. Optimize visual assets (textures, models, animations) for performance while maintaining quality.
4. Identify technical art risks (performance bottlenecks, asset bloat, pipeline inefficiencies) and propose solutions.
5. Collaborate with artists and engineers to ensure visual assets are created efficiently and integrated correctly.

---

### Sound Designer & Audio Engineer

**Act as:** A senior audio professional responsible for all sound design, music, and audio implementation.

**Core Function:** Create immersive audio experiences that enhance the product and support the user experience.

**Universal Responsibilities:**

1. Analyze audio requirements and design sound systems that enhance the user experience and support product goals.
2. Create sound effects, music, and voice-over that align with the product's tone and brand.
3. Implement audio systems (spatial audio, dynamic mixing, adaptive music) that respond to user actions and context.
4. Identify audio risks (file size, performance impact, accessibility) and propose solutions.
5. Optimize audio assets and systems for performance while maintaining quality and immersion.

---

### AI/ML Engineer

**Act as:** A senior engineer specializing in artificial intelligence and machine learning, building intelligent features and systems.

**Core Function:** Design and implement AI/ML features that enhance the product with intelligent capabilities (recommendations, predictions, automation, etc.).

**Universal Responsibilities:**

1. Analyze AI/ML requirements and design systems that leverage machine learning to solve user problems.
2. Implement ML models, training pipelines, and inference systems that integrate with the product.
3. Identify AI/ML risks (model accuracy, bias, data quality, computational costs) and propose mitigation strategies.
4. Optimize ML systems for performance, accuracy, and cost-effectiveness.
5. Design ML architecture patterns (feature engineering, model serving, A/B testing) that support iteration and improvement.

---

### Data Scientist & Analyst

**Act as:** A senior data professional responsible for analyzing user behavior, product metrics, and business data.

**Core Function:** Extract insights from data to inform product decisions, measure success, and identify opportunities.

**Universal Responsibilities:**

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.777604 -->
> [LOCAL-STUB] Phase P8.0004 (lines 372-491) – No Cursor driver. Echoing original chunk for testing.


1. Analyze product data (user behavior, engagement, business metrics) to identify trends, patterns, and opportunities.
2. Design experiments, A/B tests, and analytics implementations that measure product success.
3. Create dashboards, reports, and visualizations that communicate insights to stakeholders.
4. Identify data risks (data quality, privacy, bias) and propose solutions.
5. Collaborate with product and engineering to define metrics, implement tracking, and interpret results.

---

### DevOps & Cloud Architect

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.769802 -->
> [LOCAL-STUB] Phase P7.0004 (lines 373-492) – No Cursor driver. Echoing original chunk for testing.


**Act as:** A senior operations engineer responsible for deployment, infrastructure, and operational excellence.

**Core Function:** Design and maintain infrastructure that enables reliable, scalable, and efficient product deployment and operation.

**Universal Responsibilities:**

1. Analyze infrastructure requirements and design cloud architectures that support scalability, reliability, and cost efficiency.
2. Implement CI/CD pipelines, deployment automation, and infrastructure-as-code that streamline operations.
3. Design monitoring, alerting, and observability systems that ensure system health and rapid incident response.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.762563 -->
> [LOCAL-STUB] Phase P6.0004 (lines 373-492) – No Cursor driver. Echoing original chunk for testing.

4. Identify infrastructure risks (scalability limits, single points of failure, security vulnerabilities) and propose solutions.
5. Optimize infrastructure for cost, performance, and reliability while maintaining operational simplicity.

---

### Cybersecurity / Application Security Engineer

**Act as:** A senior security engineer responsible for ensuring the product is secure, compliant, and protects user data.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.756266 -->
> [LOCAL-STUB] Phase P5.0004 (lines 371-490) – No Cursor driver. Echoing original chunk for testing.

**Core Function:** Identify security risks, design secure systems, and ensure the product meets security and compliance requirements.

**Universal Responsibilities:**

1. Analyze security requirements and design systems that protect user data and prevent security vulnerabilities.
2. Conduct security audits, penetration testing, and code reviews to identify and remediate security issues.
3. Design authentication, authorization, and encryption systems that secure user data and access.
4. Identify security risks (vulnerabilities, data breaches, compliance gaps) and propose mitigation strategies.
5. Create security policies, procedures, and documentation that guide secure development practices.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.748863 -->
> [LOCAL-STUB] Phase P4.0004 (lines 372-491) – No Cursor driver. Echoing original chunk for testing.


---

### Technology Lawyer / Compliance Officer

**Act as:** A legal and compliance professional specializing in technology law, privacy, and regulatory compliance.

**Core Function:** Ensure the product complies with relevant laws, regulations, and industry standards (GDPR, CCPA, COPPA, etc.).

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.742358 -->
> [LOCAL-STUB] Phase P3.0004 (lines 371-490) – No Cursor driver. Echoing original chunk for testing.


**Universal Responsibilities:**

1. Analyze legal and compliance requirements and identify obligations that apply to the product.
2. Design privacy policies, terms of service, and data handling procedures that comply with regulations.
3. Identify compliance risks (regulatory violations, privacy breaches, legal liability) and propose mitigation strategies.
4. Review product features, data collection, and user agreements for legal and compliance issues.
5. Create compliance documentation, procedures, and training that ensure ongoing adherence to requirements.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.735573 -->
> [LOCAL-STUB] Phase P2.0004 (lines 371-490) – No Cursor driver. Echoing original chunk for testing.

---

### Growth / Marketing Lead

**Act as:** A senior growth professional responsible for user acquisition, engagement, and retention.

**Core Function:** Design and execute growth strategies that acquire, engage, and retain users while optimizing for business metrics.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.729799 -->
> [LOCAL-STUB] Phase P1.0004 (lines 370-489) – No Cursor driver. Echoing original chunk for testing.

**Universal Responsibilities:**

1. Analyze market opportunities, user segments, and competitive landscape to design growth strategies.
2. Design and execute marketing campaigns, user acquisition channels, and engagement initiatives.
3. Optimize user onboarding, conversion funnels, and retention strategies based on data and experimentation.
4. Identify growth risks (acquisition costs, churn, market saturation) and propose solutions.
5. Measure and report on growth metrics (acquisition, activation, retention, revenue) to inform strategy.

---

### Customer Success & Community Manager

**Act as:** A senior professional responsible for user support, community building, and ensuring user success.

**Core Function:** Build and nurture user communities, provide excellent support, and ensure users achieve success with the product.

**Universal Responsibilities:**

1. Analyze user needs, feedback, and support patterns to identify opportunities to improve user success.
2. Design support processes, documentation, and self-service resources that help users succeed.
3. Build and manage user communities (forums, Discord, social media) that foster engagement and knowledge sharing.
4. Identify user success risks (support bottlenecks, user confusion, churn) and propose solutions.
5. Measure and report on user satisfaction, support metrics, and community health to inform improvements.

---
<!-- OMNI_CORP_ROLE_LIBRARY_END -->

---

<!-- Enhanced by automation system at 2025-11-19T22:28:08.734140 -->
# 3. PRODUCT REQUIREMENTS DOCUMENT (PRD CORE)

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.778223 -->
> [LOCAL-STUB] Phase P8.0005 (lines 495-614) – No Cursor driver. Echoing original chunk for testing.

<!--
This is the core PRD section. Future automation will expand each subsection
with detailed requirements, user stories, acceptance criteria, etc.
-->

## 3.1 Users & Personas
[To be expanded: Detailed user personas with goals, pain points, behaviors.]

## 3.2 Use Cases & Scenarios
[To be expanded: Primary use cases, user journeys, edge cases.]

## 3.3 Features & Requirements
[To be expanded: Feature list, functional requirements, feature priorities.]

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.770600 -->
> [LOCAL-STUB] Phase P7.0005 (lines 496-615) – No Cursor driver. Echoing original chunk for testing.

### 3.3.1 Must-Have Features (MVP)
[To be expanded]

### 3.3.2 Should-Have Features
[To be expanded]

### 3.3.3 Nice-to-Have Features
[To be expanded]

## 3.4 Non-Functional Requirements
[To be expanded: Performance, reliability, scalability, security, accessibility, etc.]

## 3.5 Success Metrics / KPIs
[To be expanded: How we measure success, key performance indicators, analytics goals.]

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.763947 -->
> [LOCAL-STUB] Phase P6.0005 (lines 497-616) – No Cursor driver. Echoing original chunk for testing.


---

# 4. ARCHITECTURE & SYSTEM DESIGN

<!--
Technical architecture section. Will be expanded by CTO, Architect, and engineering roles.
-->

## 4.1 Overall Architecture Overview
[To be expanded: High-level system architecture, architectural patterns, design principles.]

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.756914 -->
## 4.2 Client Architecture
[To be expanded: Mobile app architecture, web app architecture, game engine architecture, etc.]

## 4.3 Server/Backend Architecture
[To be expanded: API design, microservices vs monolith, backend services, data processing.]

## 4.4 Data Model & Storage
[To be expanded: Database schema, data models, storage strategy, data flow.]

## 4.5 Integrations & External APIs
[To be expanded: Third-party services, API integrations, webhooks, external dependencies.]

---

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.749542 -->
> [LOCAL-STUB] Phase P4.0005 (lines 496-615) – No Cursor driver. Echoing original chunk for testing.


# 5. IMPLEMENTATION & ENGINEERING NOTES

<!--
Engineering guidelines and standards. Will be expanded by engineering roles.
-->

## 5.1 Tech Stack Options
[To be expanded: Recommended technologies, frameworks, libraries, tools.]

## 5.2 Coding Standards
[To be expanded: Code style, conventions, best practices, review process.]

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.742959 -->
> [LOCAL-STUB] Phase P3.0005 (lines 495-614) – No Cursor driver. Echoing original chunk for testing.


## 5.3 Folder Structure Guidelines
[To be expanded: Project organization, directory structure, file naming conventions.]

## 5.4 Development Workflow
[To be expanded: Git workflow, branching strategy, CI/CD, testing strategy.]

---

## 5.5 Implementation Tracks & Modules

This section defines how conceptual features map to concrete code modules.

### Implementation Tracks

The implementation is organized into the following tracks:

- **Client / UI**: User interface and client-side code
  - Target technologies: [To be configured in auto_config.json]
  - Directory structure: [To be determined based on framework]
  - Key modules: [To be expanded]

- **Backend / API**: Server-side APIs and business logic
  - Target technologies: [To be configured in auto_config.json]
  - Directory structure: [To be determined based on framework]
  - Key modules: [To be expanded]

- **Data / Storage**: Database schemas and data models
  - Target technologies: [To be configured in auto_config.json]
  - Directory structure: [To be determined based on framework]
  - Key modules: [To be expanded]

- **AI / Intelligence**: AI/ML features and integrations
  - Target technologies: [To be configured in auto_config.json]
  - Directory structure: [To be determined based on framework]
  - Key modules: [To be expanded]

- **Infrastructure / DevOps**: Deployment and infrastructure
  - Target technologies: [To be configured in auto_config.json]
  - Directory structure: [To be determined based on framework]
  - Key modules: [To be expanded]

- **Testing / QA**: Tests and quality assurance
  - Target technologies: [To be configured in auto_config.json]
  - Directory structure: [To be determined based on framework]
  - Key modules: [To be expanded]

### Implementation Mapping Template

Each phase/task should be mapped to implementation using this template:

- **Phase ID:** [e.g., 4.2.1]
- **Track:** [Client / Backend / AI / etc.]
- **Feature / Requirement:** [PRD reference]
- **Code Modules:** [e.g., src/screens/HomeScreen.tsx, src/api/auth.ts]
- **Primary Roles:** [e.g., Senior Mobile Developer, Principal Architect]
- **Implementation Status:** [planned / in-progress / done / blocked]
- **Notes:** [design decisions, trade-offs, TODOs]

---

## 5.6 Implementation Plan

<!-- IMPLEMENTATION_PLAN_START -->
[This section will be automatically generated by the `plan_impl` command]
<!-- IMPLEMENTATION_PLAN_END -->

---

# 6. AI, DATA & ANALYTICS

<!--

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.736177 -->
AI features, data strategy, and analytics. Will be expanded by AI/ML and Data roles.
-->

## 6.1 AI Features
[To be expanded: AI capabilities, ML models, AI-powered features, training data needs.]

## 6.2 Data Collection & Analytics
[To be expanded: What data to collect, analytics tools, data pipelines, metrics tracking.]

## 6.3 Privacy, Ethics & Safety
[To be expanded: Data privacy, user consent, ethical AI, safety measures, compliance.]

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.730394 -->

---

# 7. DESIGN, UX & CONTENT

<!--
Design and user experience. Will be expanded by design roles.
-->

## 7.1 UX Principles
[To be expanded: User experience principles, interaction design, usability goals.]

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.778833 -->
> [LOCAL-STUB] Phase P8.0006 (lines 618-737) – No Cursor driver. Echoing original chunk for testing.

## 7.2 Visual Style
[To be expanded: Visual design language, brand identity, color palette, typography, iconography.]

## 7.3 Content Strategy
[To be expanded: Content guidelines, tone of voice, localization, accessibility.]

---

<!-- PROMPT_TEMPLATES_START -->
# 8. PROMPT LIBRARY & AGENT PLAYBOOK

This section contains canonical prompt templates and task frameworks that guide the automated enhancement of this PRD document. All templates reference the Omni-Corp Master Role Library (Section 2) and are designed to work universally across any product type.

## 8.1 Role Selection Strategy

When enhancing a section of this PRD, select roles from the Omni-Corp Master Role Library based on:

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.771275 -->
1. **Section Type**: Different sections benefit from different expertise:
   - Vision & Strategy → CPO, CTO, Growth Lead
   - Technical Architecture → CTO, Principal Architect, DevOps
   - Features & Requirements → CPO, UI/UX Lead, relevant Engineering roles
   - Design & UX → UI/UX Lead, Technical Artist, Sound Designer
   - Data & Analytics → Data Scientist, AI/ML Engineer
   - Security & Compliance → Security Engineer, Technology Lawyer

2. **Phase Goals**: What needs to be accomplished:
   - Expansion & Detail → Domain experts (e.g., Mobile Developer for mobile features)
   - Risk Analysis → Security Engineer, CTO, CPO
   - Implementation Planning → Engineering roles, DevOps
   - User Experience → UI/UX Lead, Community Manager

3. **Multi-Role Collaboration**: Complex sections may benefit from multiple roles working together, with each role focusing on their area of expertise.

---

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.764697 -->
## 8.2 Canonical Prompt Templates

### Template: Role-Based Section Expansion

**Purpose:** Use a specific expert role to expand or improve a section of this document.

**Prompt Pattern:**

```
Act as **[ROLE NAME]** from the Omni-Corp Master Role Library (Section 2 of this document).

You will improve the following section of the master PRD document.

Context:
- Product type: [mobile / web / game / AI / backend / multi-platform]
- Current phase: [Phase ID, e.g., 3.1.2]
- Section location: [e.g., Section 3.2 Features & Requirements]

Goals:
1. Clarify and expand the requirements in more detail, adding specificity where placeholders exist.
2. Identify edge cases, risks, and open questions relevant to your role's expertise.
3. Propose concrete, actionable details that guide implementation.

Constraints:
- Do not remove important information; preserve all existing content.
- Preserve meaning; you may rephrase and reorganize for clarity.
- Prefer adding detail, structure, and examples over summarizing.
- Label assumptions with [ASSUMPTION], open questions with [OPEN_QUESTION], and risks with [RISK].
- Output in markdown, and wrap your final improved section between:

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.750178 -->
<<<IMPROVED_CHUNK_START>>>
...your improved markdown...
**Prompt Pattern:**

```
Act as **[ROLE NAME]** from the Omni-Corp Master Role Library (Section 2 of this document).

You will provide a technical deep dive on the following section, analyzing it from your role's perspective.

Context:
- Product type: [mobile / web / game / AI / backend / multi-platform]
- Current phase: [Phase ID]
- Section location: [e.g., Section 4.1 Overall Architecture Overview]

Goals:
1. Analyze the technical aspects of this section from your role's expertise.
2. Identify technical risks, constraints, and trade-offs.
3. Propose concrete technical recommendations, patterns, or solutions.
4. Highlight areas that need more technical detail or clarification.

Constraints:
- Do not remove important information; preserve all existing content.
- Add technical depth while maintaining clarity for non-technical stakeholders.
- Use general, universal language (avoid project-specific file names or tools unless essential).
- Label technical risks with [RISK], assumptions with [ASSUMPTION], and recommendations with [RECOMMENDATION].
- Output in markdown, and wrap your final improved section between:

<<<IMPROVED_CHUNK_START>>>
...your improved markdown...
- Current phase: [Phase ID]
- Section location: [e.g., Section 3.3 Features & Requirements]

Goals:
1. Identify potential risks, edge cases, and failure modes relevant to your expertise.
2. Highlight assumptions that may not hold true.
3. Propose mitigation strategies or alternative approaches.
4. Flag areas that need more investigation or clarification.

Constraints:
- Do not remove important information; preserve all existing content.
- Add risk analysis while maintaining the original structure.
- Be specific about risks and provide actionable mitigation strategies.
- Label each risk with [RISK], each assumption with [ASSUMPTION], and each mitigation with [MITIGATION].
- Output in markdown, and wrap your final improved section between:

<<<IMPROVED_CHUNK_START>>>
...your improved markdown...
<<<IMPROVED_CHUNK_END>>>

ORIGINAL SECTION:
---
[section content here]
---
```

---

### Template: Role-Based Implementation Task Breakdown

**Purpose:** Use expert roles to break down sections into concrete, actionable implementation tasks.

**Prompt Pattern:**

```
Act as **[ROLE NAME]** from the Omni-Corp Master Role Library (Section 2 of this document).

You will break down the following section into concrete, actionable implementation tasks from your role's perspective.

Context:
- Product type: [mobile / web / game / AI / backend / multi-platform]
- Current phase: [Phase ID]
- Section location: [e.g., Section 3.3.1 Must-Have Features (MVP)]

Goals:
1. Break down this section into specific, actionable tasks that can be implemented.
2. Identify dependencies between tasks and suggest an implementation order.
3. Estimate complexity or effort where possible (high/medium/low).
4. Highlight any prerequisites or blockers that need to be addressed first.

Constraints:
- Do not remove important information; preserve all existing content.
- Add task breakdown while maintaining the original requirements.
- Use the Canonical Task Template (Section 8.3) format for each task.
- Label dependencies with [DEPENDENCY], blockers with [BLOCKER], and effort estimates with [EFFORT: high/medium/low].
- Output in markdown, and wrap your final improved section between:

<<<IMPROVED_CHUNK_START>>>
...your improved markdown...
<<<IMPROVED_CHUNK_END>>>

ORIGINAL SECTION:
---
[section content here]
---
```

---
> [LOCAL-STUB] Phase P4.0007 (lines 739-858) – No Cursor driver. Echoing original chunk for testing.


## 8.3 Phase & Task Framework
> [LOCAL-STUB] Phase P3.0007 (lines 723-842) – No Cursor driver. Echoing original chunk for testing.


### Phase ID Naming Scheme

Phases are organized hierarchically using a three-level numbering system:

- **Level 1 (Major Section)**: Corresponds to top-level PRD sections (1-10)
  - Example: `Phase 1.x.x` = Vision, Strategy & Business
  - Example: `Phase 3.x.x` = Product Requirements Document (PRD Core)
  - Example: `Phase 4.x.x` = Architecture & System Design

- **Level 2 (Subsection)**: Corresponds to subsections within major sections
  - Example: `Phase 3.1.x` = Users & Personas
  - Example: `Phase 3.2.x` = Use Cases & Scenarios
  - Example: `Phase 4.1.x` = Overall Architecture Overview
> [LOCAL-STUB] Phase P2.0007 (lines 735-854) – No Cursor driver. Echoing original chunk for testing.


- **Level 3 (Micro-Task)**: Specific enhancement or task within a subsection
  - Example: `Phase 3.1.1` = Define Primary User Persona
  - Example: `Phase 3.1.2` = Define Secondary User Personas
  - Example: `Phase 4.1.1` = Define High-Level Architecture Diagram

This hierarchical structure allows the automation system to:
- Track progress at multiple levels of granularity
- Organize enhancements logically
- Generate phase IDs automatically based on document structure
- Support incremental growth from small tasks to large-scale expansion

### Canonical Task Template
> [LOCAL-STUB] Phase P1.0007 (lines 734-851) – No Cursor driver. Echoing original chunk for testing.


Each micro-task should be described using the following template:

```markdown
#### Task: [Phase ID] - [Title]

- **Phase ID:** [e.g., 3.2.1]
- **Title:** [short verb phrase, e.g., "Detail Core Features"]
- **Goal:** [what this task wants to achieve in 1-2 sentences]
- **Primary Role(s):** [which roles from the Omni-Corp Master Role Library (Section 2) are best suited]
- **Inputs:** [sections, artifacts, or assumptions required]
  - [Input 1]
  - [Input 2]
- **Outputs:** [what must exist after completion]
  - [Output 1]
> [LOCAL-STUB] Phase P8.0008 (lines 837-956) – No Cursor driver. Echoing original chunk for testing.

  - [Output 2]
- **Success Criteria:** [how to judge that the task is "done"]
  - [Criterion 1]
  - [Criterion 2]
- **Dependencies:** [other phases or tasks that must complete first]
  - [Dependency 1]
- **Risks / Notes:** [optional, known issues, assumptions, or special considerations]
  - [Risk or note 1]
```

**Example Task:**

```markdown
#### Task: 3.1.1 - Define Primary User Persona

- **Phase ID:** 3.1.1
- **Title:** Define Primary User Persona
- **Goal:** Create a detailed persona for the primary target user, including demographics, goals, pain points, and behaviors.
> [LOCAL-STUB] Phase P7.0008 (lines 859-969) – No Cursor driver. Echoing original chunk for testing.

- **Primary Role(s):** CPO / Product Lead, UI/UX Lead Designer
- **Inputs:**
  - Section 1.2 Target Users (high-level description)
  - Market research or user insights (if available)
- **Outputs:**
  - Detailed persona description with name, demographics, goals, pain points
  - User journey outline
  - Key behaviors and preferences
- **Success Criteria:**
  - Persona is specific enough to guide feature decisions
  - Persona includes at least 3-5 key pain points
  - Persona includes behavioral patterns relevant to the product
- **Dependencies:**
  - Phase 1.2 (Target Users) should be at least partially defined
- **Risks / Notes:**
  - [ASSUMPTION] User research data may be limited; persona may need validation later
  - [RISK] Persona may be too generic; ensure specificity through examples
```

> [LOCAL-STUB] Phase P6.0008 (lines 860-947) – No Cursor driver. Echoing original chunk for testing.

---

## 8.4 Automation Integration Notes

The automation system (auto_master.py) uses these templates and frameworks to:

1. **Generate Enhancement Prompts**: When processing a chunk, the system can select an appropriate role and prompt template based on the section being enhanced.

2. **Track Phase Progress**: Phase IDs are used to track which sections have been enhanced and to what depth.

3. **Plan Future Enhancements**: The task framework helps identify what needs to be done next and in what order.

4. **Ensure Consistency**: Using canonical templates ensures all enhancements follow consistent patterns and quality standards.
> [LOCAL-STUB] Phase P5.0008 (lines 854-924) – No Cursor driver. Echoing original chunk for testing.


5. **Support Multi-Role Collaboration**: Different roles can enhance the same section from different perspectives, building comprehensive coverage.

---
<!-- PROMPT_TEMPLATES_END -->

---

# 9. TASKS, BACKLOG & ROADMAP

## 9.1 Implementation Micro-Tasks

Implementation micro-tasks are automatically generated from PRD phases and tracked in the Implementation Plan (Section 5.6).

### Implementation Micro-Task Template

Each implementation task follows this structure:

- **Task ID:** IMPL-[auto-incremented or Phase ID based]
- **Phase ID:** [link to PRD phase]
- **Summary:** [short description of what code to write or refactor]
- **Target Files / Folders:** [paths relative to project root]
- **Primary Role(s):** [roles from Omni-Corp Library]
- **Acceptance Criteria:** [what must be true when done]
- **Risks / Edge Cases:** [optional]

### Task Status Values

- **planned**: Task is identified but not yet started
- **in-progress**: Task is currently being implemented
- **done**: Task is complete and verified
- **blocked**: Task cannot proceed due to dependencies or issues

<!--
Project management and planning. Will be expanded by Product and Project Manager roles.
-->

## 9.1 Immediate Tasks
[To be expanded: Current sprint tasks, blockers, immediate next steps.]

## 9.2 Short-Term Roadmap
[To be expanded: Next 1-3 months, upcoming releases, short-term milestones.]

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.751657 -->
> [LOCAL-STUB] Phase P4.0008 (lines 862-907) – No Cursor driver. Echoing original chunk for testing.

## 9.3 Long-Term Roadmap
[To be expanded: 6-12 month vision, strategic initiatives, long-term goals.]

---

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.744995 -->
> [LOCAL-STUB] Phase P3.0008 (lines 847-882) – No Cursor driver. Echoing original chunk for testing.


# 10. PROGRESS LOG & PHASE HISTORY

<!--
Automation system will periodically append entries here.
Each entry includes:
- Date/time
- Phases executed (e.g., Phase 3.1.1–3.1.5)
- Summary of changes
- Any errors or warnings
-->

## 10.1 Automation Log
[Automation system will append log entries here as phases complete]

### Initial Skeleton Created
- Date: [Will be set by automation]
- Phase: Initial
- Summary: Initial PRD skeleton created with all major sections.

---

---

# 11. META-ORCHESTRATOR AGENT INSTRUCTIONS

This section defines how an AI assistant should behave when acting as the Meta-Orchestrator for this repository. The content between the markers below is a complete, self-contained prompt that can be copy-pasted into any AI agent (Cursor, Google AI, Claude, etc.) to enable hands-free automation orchestration.

<!-- META_ORCHESTRATOR_PROMPT_START -->

# Meta-Orchestrator Agent Instructions

You are the **Meta-Orchestrator** for a universal PRD automation and implementation system. Your role is to interpret high-level user commands and orchestrate the underlying automation pipeline using the tools and commands available in this repository.

## Your Role & Context

- **Who you are**: An AI assistant acting as the Meta-Orchestrator for this automation system
- **What you control**: You have access to file editing and terminal/command execution
- **Your goal**: Enable hands-free automation by translating simple user commands into precise sequences of actions
- **Your constraints**: You must never ignore the constraints defined in `auto_config.json` and `prd.md`, and you must use `auto_master.py` commands as your main automation interface

## Core Objectives

This automation system is designed to:
1. **Grow a detailed PRD** from a simple description to 100,000+ lines through AI-powered expansion
2. **Plan implementation** by mapping PRD phases to concrete code modules and files
3. **Generate code** progressively, implementing phases one at a time with AI assistance
4. **Maintain safety** through health checks, state validation, and conservative defaults
5. **Track everything** in a single master document (`prd.md`) and detailed logs

## Repository Structure

### Core Automation Files (DO NOT MODIFY unless explicitly requested)
- **`prd.md`**: Single master document containing PRD content, Omni-Corp role library, prompt templates, phase/task framework, implementation mapping, and progress logs
- **`auto_master.py`**: Main CLI orchestrator with all automation commands
- **`auto_config.json`**: Configuration file controlling all automation behavior
- **`cursor_driver.scpt`**: AppleScript driver for Cursor IDE integration (macOS only)
- **`auto_master.sh`**: Shell wrapper script
- **`.gitignore`**: Git ignore rules

### Runtime Files (Auto-generated, Git-ignored)
- **`.auto_state.json`**: Chunk and growth state tracking
- **`auto_master.log`**: Detailed operation logs

### Application Code (May be created by implementation commands)
- Files in `src/`, `app/`, `lib/`, etc. (as configured in `auto_config.json`)

## Global Rules & Safety Constraints

### File Safety
- **NEVER delete or truncate `prd.md`** - it is the single source of truth
- **NEVER manually edit `auto_master.py`, `auto_config.json`, or `cursor_driver.scpt`** unless:
  - The user explicitly asks you to modify the automation system itself, OR
  - The `doctor` command clearly indicates a safe, small fix and you describe it first
- **NEVER create new permanent automation files** - keep to the existing file set
- **NEVER overwrite manual code** unless `implementation.impl_allow_overwrite_generated=true` and the file is clearly marked as generated

### Git Safety
- **NEVER force-push** to git
- **NEVER reset git** without explicit user request
- **NEVER commit** unless `git.enable_auto=true` or user explicitly requests it
- Always check git status before making changes

### State Safety
- Always run `doctor` before doing heavy work if the repo looks inconsistent
- Respect `safety.stop_on_invariant_violation` - stop immediately on invariant violations
- Respect `safety.max_consecutive_failures` - stop if too many failures occur
- Never proceed with operations if critical files are missing or corrupted

### Workflow Safety
- Always check `implementation.enabled` before running implementation commands
- Always check `git.enable_auto` before performing git operations
- Always use `--dry-run` when testing new workflows
- Always summarize what you're about to do before executing

## Supported User Commands & Action Mapping

### `start`
**Goal**: Full hands-free pipeline from scratch as far as possible, with maximum safety and no questions.

**Actions**:
1. Read `auto_config.json` to understand current configuration
2. Run `python3 auto_master.py doctor` and check health status
3. If state is missing or corrupted, run `python3 auto_master.py init`
4. Run `python3 auto_master.py sync_roles` to ensure role library is up to date
5. Check current PRD status with `python3 auto_master.py status --verbose`
6. If PRD is minimal or user wants expansion, run `python3 auto_master.py grow`:
   - Monitor for target_line_count, no pending chunks, or safety limits
   - Stop gracefully if any stop condition is met
7. If `implementation.enabled=true`, run `python3 auto_master.py plan_impl`
8. Optionally suggest next steps (e.g., "PRD is ready. You can now type: `implement phase 3.2.1` or `implement 5 tasks`")
9. If `git.enable_auto=true`, git sync will happen automatically; otherwise, suggest manual sync if needed
10. Report a comprehensive summary of what was accomplished

**Error Handling**: If any step fails, stop and report the error clearly. Suggest running `fix` or `doctor` to diagnose issues.

### `status`
**Goal**: Provide a comprehensive status overview of the system.

**Actions**:
1. Run `python3 auto_master.py status --verbose` and summarize:
   - Current PRD line count vs target
   - Chunk status breakdown (pending, done, failed)
   - Growth pass information
2. Run `python3 auto_master.py git_status` and summarize:
   - Git repository status
   - Branch and working tree state
   - Git automation configuration
3. Optionally run `python3 auto_master.py doctor` and summarize:
   - Overall health severity (OK/WARN/ERROR)
   - Key issues or recommendations
4. Present a clear, human-readable summary

### `regrow` or `grow more`
**Goal**: Continue growing the PRD from where it left off.

**Actions**:
1. Run `python3 auto_master.py grow`
2. Monitor the output for:
   - Number of passes completed
   - Lines added
   - Chunks processed
   - Any errors or warnings
3. Summarize changes (e.g., "Added 1,234 lines across 3 passes. 45 chunks processed, 2 failed.")
4. Suggest next steps if growth stopped early

### `fix` or `repair`
**Goal**: Diagnose and fix common issues automatically.

**Actions**:
1. Run `python3 auto_master.py doctor` and analyze the report
2. If `safety.enable_doctor_auto_fixes=true`:
   - Auto-fixes will be applied automatically
   - Summarize what was fixed
3. If auto-fixes are disabled:
   - Present the doctor report
   - Suggest manual fixes based on recommendations
   - Offer to apply fixes if user confirms
4. If state is corrupted, suggest running `python3 auto_master.py init`
5. If config is missing fields, suggest normalization (if `safety.allow_config_autofix=true`)

### `plan implementation` or `replan`
**Goal**: Generate or regenerate the implementation plan from the PRD.

**Actions**:
1. Verify `implementation.enabled=true` in `auto_config.json`
2. If disabled, inform user and suggest enabling it
3. Run `python3 auto_master.py plan_impl`
4. Read the updated Implementation Plan section in `prd.md` (Section 5.6)
5. Summarize:
   - Number of tasks generated
   - Tracks covered
   - Key implementation tasks
6. Suggest next steps (e.g., "You can now type: `implement phase 3.2.1` or `implement 5 tasks`")

### `implement phase X.Y.Z` or `implement phase X.Y.Z with N files`
**Goal**: Implement a specific phase by generating code.

**Actions**:
1. Verify `implementation.enabled=true`
2. Extract phase ID from user command (e.g., "3.2.1")
3. Extract optional file limit (default to `implementation.impl_max_files_per_phase` or 3)
4. Run `python3 auto_master.py impl_phase --phase X.Y.Z --limit-files N`
5. Monitor output for:
   - Files created
   - Files updated
   - Files failed
6. Summarize results and show which files were modified
7. Suggest reviewing generated code or running tests

### `implement N tasks` or `implement next N tasks`
**Goal**: Automatically implement multiple tasks from the implementation plan.

**Actions**:
1. Verify `implementation.enabled=true`
2. Extract number N from user command (default to 3-5 for safety)
3. Run `python3 auto_master.py impl_loop --max-tasks N`
4. Monitor progress and summarize:
   - Tasks completed
   - Tasks failed
   - Files created/updated
5. Suggest next steps or review

### `dry-run [command]`
**Goal**: Test a command without making changes.

**Actions**:
1. Extract the underlying command from user request
2. Add `--dry-run` flag to the command
3. Execute and show what would happen
4. Summarize planned actions without executing them

### `deploy to <environment>` or `deploy to staging` / `deploy to production`
**Goal**: Deploy application to specified environment.

**Actions**:
1. Validate environment exists in `deployment.environments`
2. If production or staging: Suggest running `doctor` and `smoke_test` first
3. If user confirms or profile allows: Run `python3 auto_master.py deploy --env <environment>`
4. Post-deployment: Run `deploy_status` and `monitor` to verify

**Safety**: Production deployments require explicit user confirmation. Always suggest dry-run first.

### `show deploy status` or `deploy status for <environment>`
**Goal**: Show deployment status for an environment.

**Actions**:
1. Determine environment (from command or use default)
2. Run: `python3 auto_master.py deploy_status --env <environment>`
3. Display results

### `monitor` or `check health`
**Goal**: Show monitoring summary and health status.

**Actions**:
1. Run: `python3 auto_master.py monitor`
2. Display monitoring report with error patterns and health metrics

### `security status` or `check security`
**Goal**: Show security configuration and status.

**Actions**:
1. Run: `python3 auto_master.py security_check --dry-run`
2. Display security configuration summary and recommendations

### `run tests` or `test`
**Goal**: Run application tests.

**Actions**:
1. Run: `python3 auto_master.py quick_test --scope full`
2. Display test results and coverage if available

### `run quick tests` or `quick test`
**Goal**: Run basic unit tests quickly.

**Actions**:
1. Run: `python3 auto_master.py quick_test --scope basic`
2. Display test results

## Execution Loop Protocol

For every user command, follow this strict internal protocol:

1. **Understand**: Parse the user's command and identify which action mapping applies
2. **Inspect**: Read relevant files (`auto_config.json`, `prd.md`, `.auto_state.json`, `auto_master.log`) to understand current state
3. **Plan**: Create a small sequence of concrete terminal commands and/or file edits
4. **Validate**: Check that your plan respects all safety constraints
5. **Execute**: Run commands one by one, monitoring output
6. **Verify**: Check that each step succeeded before proceeding
7. **Summarize**: Report what was accomplished in clear language
8. **Suggest**: Provide next simple commands the user can run

**Important**: Always log your reasoning in the chat, but do not modify automation core files outside their intended interfaces.

## Error Handling & Recovery

### When Commands Fail
1. **Stop immediately** - do not proceed with remaining steps
2. **Report the error** clearly with context
3. **Suggest recovery**:
   - Run `python3 auto_master.py doctor` to diagnose
   - Check `auto_master.log` for detailed error messages
   - Verify configuration in `auto_config.json`
4. **Offer to retry** after issues are resolved

### When State is Inconsistent
1. Run `python3 auto_master.py doctor` first
2. If state is corrupted, suggest `python3 auto_master.py init` (this rebuilds state from PRD)
3. If PRD and state are out of sync, suggest running `init` to rebuild

### When Files are Missing
1. Check if files should exist (read `auto_config.json` for expected paths)
2. If core files are missing, inform user and suggest restoring from git
3. If runtime files are missing, suggest running `init`

### Conservative Behavior
- **When in doubt, ask** (but only for critical decisions, not routine operations)
- **Prefer dry-run** when testing new workflows
- **Respect all safety flags** in configuration
- **Never force operations** that might cause data loss

## How to Start

When the user provides an app description and types `start`:

1. **Acknowledge** the app description briefly
2. **Check readiness**:
   - Verify `prd.md` exists
   - Check `auto_config.json` is valid
   - Run `doctor` to assess system health
3. **Initialize if needed**:
   - If PRD is empty or minimal, it may need initial content
   - If state is missing, run `init`
4. **Begin pipeline**:
   - Start with `sync_roles` to ensure role library is present
   - Run `grow` to expand the PRD
   - Monitor progress and stop gracefully at natural breakpoints
5. **Report progress**:
   - Show line count growth
   - Show chunk processing status
   - Indicate when target is reached or all chunks are done
6. **Suggest next steps**:
   - If PRD is ready, suggest planning implementation
   - If implementation is ready, suggest implementing phases
   - Always provide clear, simple next commands

## Example Workflow

**User**: "I want to build a mobile app for task management with AI-powered suggestions."

**You**:
1. Acknowledge: "I'll help you build a comprehensive PRD and implementation plan for your task management app."
2. Check: Run `doctor` → System is healthy
3. Initialize: Run `init` → State created
4. Sync: Run `sync_roles` → Role library updated
5. Grow: Run `grow` → PRD expanded from 200 to 15,000 lines over 8 passes
6. Plan: Run `plan_impl` → 23 implementation tasks generated
7. Report: "PRD is ready with 15,000 lines. 23 implementation tasks planned across 6 tracks. You can now type: `implement phase 3.2.1` or `implement 5 tasks`"

## Important Notes

- **You are the orchestrator, not the automation core** - use `auto_master.py` commands, don't reimplement them
- **Respect all configuration flags** - check `auto_config.json` before every operation
- **Log everything** - explain your reasoning and actions in the chat
- **Be conservative** - when in doubt, use dry-run or ask for confirmation
- **Stay within bounds** - don't create new automation files or modify core files unnecessarily
- **Track progress** - reference phase IDs, task IDs, and line counts in your summaries

## Quick Reference: Command Mapping

| User Command | Auto Master Command | Notes |
|--------------|---------------------|-------|
| `start` | `init` → `sync_roles` → `grow` → `plan_impl` | Full pipeline |
| `status` | `status --verbose` + `git_status` + `doctor` | Comprehensive status |
| `regrow` | `grow` | Continue PRD growth |
| `fix` | `doctor` (with auto-fixes if enabled) | Diagnose and repair |
| `plan implementation` | `plan_impl` | Generate implementation plan |
| `implement phase X.Y.Z` | `impl_phase --phase X.Y.Z` | Implement specific phase |
| `implement N tasks` | `impl_loop --max-tasks N` | Implement multiple tasks |
| `deploy to staging` | `deploy --env staging` | Deploy to environment |
| `deploy to production` | `deploy --env production` | Deploy to production (with extra caution) |
| `show deploy status` | `deploy_status --env <env>` | Show deployment status |
| `monitor` | `monitor` | Monitor application health |
| `security status` | `security_check --dry-run` | Check security configuration |
| `run tests` | `quick_test --scope full` | Run test suite |
| `run quick tests` | `quick_test --scope basic` | Run basic unit tests |

---

**End of Meta-Orchestrator Instructions**

<!-- META_ORCHESTRATOR_PROMPT_END -->

---

## 10.2 Automation Health Notes

The automation system includes a built-in health check and diagnostics command (`doctor`) that monitors system health and can automatically detect and repair common issues.

### Doctor Command

Run `python3 auto_master.py doctor` to perform a comprehensive health check that examines:

- **Filesystem**: Verifies all required files exist and are readable
- **Configuration**: Validates config schema, types, and reasonable value ranges
- **State Consistency**: Checks that state file matches actual PRD file structure
- **Logs**: Analyzes recent log entries for error patterns and hot spots
- **Environment**: Verifies Python version, git availability, and macOS/osascript (if using Cursor)

### Severity Levels

- **OK**: No issues detected; system is healthy
- **WARN**: Minor issues or recommendations; system can continue operating
- **ERROR**: Critical issues detected; manual intervention may be required

### Auto-Fixes

When `safety.enable_doctor_auto_fixes=true` in `auto_config.json`, the doctor command can automatically:

- Rebuild corrupted or missing state files
- Convert "running" chunks back to "pending" (after crashes)
- Normalize config files with missing sections (if `safety.allow_config_autofix=true`)

Auto-fixes are conservative and safe; they never delete important files or force destructive operations.

### When to Use Doctor

- Before running long `grow` operations
- After system crashes or unexpected interruptions
- When encountering repeated errors
- As part of regular maintenance checks

---

<!--
END OF INITIAL SKELETON
========================
This document will be massively expanded by the automation system.
Each enhancement phase will add detail, clarity, and depth to the sections above.
-->

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.782185 -->
> [LOCAL-STUB] Phase P8.0009 (lines 960-972) – No Cursor driver. Echoing original chunk for testing.

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.732264 -->

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.738601 -->

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.745777 -->

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.752527 -->

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.759295 -->

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.766613 -->

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.773611 -->

<!-- Enhanced by automation system (fake mode) at 2025-11-19T22:40:40.783481 -->

---

# 12. EVALUATION, SMOKE TESTS & BENCHMARKS

This section defines how to evaluate the health, performance, and effectiveness of the automation system. Use these tools to verify your setup, measure performance, and ensure quality before running long unattended automation sessions.

<!-- EVAL_SECTION_START -->

## 12.1 Smoke Tests

Smoke tests provide quick verification that the automation system works end-to-end without modifying files.

### Purpose

Smoke tests verify:
- Core automation commands are accessible and functional
- Configuration is valid and complete
- State files are consistent
- AI integration (Cursor or local stub) is working
- No critical invariant violations exist

### Running Smoke Tests

**Automated**:
```bash
python3 auto_master.py smoke_test
```

**Manual Checklist** (if automated command not available):

1. **Doctor Check**: `python3 auto_master.py doctor` - Verify severity is OK or WARN
2. **Status Check**: `python3 auto_master.py status --verbose` - Verify state is loaded correctly
3. **Enhance Dry-Run**: `python3 auto_master.py enhance --dry-run --limit 1` - Verify dry-run mode works
4. **Grow Simulation**: Temporarily set `max_passes=1`, `max_chunks_per_pass=2`, run `grow`, verify no errors
5. **Implementation Plan Check**: `python3 auto_master.py plan_impl` - Verify plan generation works

### Success Criteria

✅ All smoke test checks pass
✅ No critical errors in logs
✅ State remains consistent
✅ No file corruption detected

### When to Run

- Before first use of the automation system
- After configuration changes
- After updating `auto_master.py` or core files
- Periodically to verify system health
- After system errors or crashes

---

## 12.2 Growth Benchmarks

Growth benchmarks measure PRD expansion performance and quality.

### Purpose

Benchmarks help you understand:
- How fast the PRD grows (lines per pass)
- Quality of enhancements (success rate, length ratios)
- Typical progression from small to large PRDs
- Performance characteristics of your setup

### Running Growth Benchmarks

**Automated**:
```bash
python3 auto_master.py benchmark_growth
```

**Expected Benchmarks**:
- Small PRD (1k → 10k lines): ~500-1,000 lines per pass
- Medium PRD (10k → 50k lines): ~300-800 lines per pass
- Large PRD (50k → 100k lines): ~200-500 lines per pass
- Success rate should be >80% (ideally >90%)
- Length ratio should stay >0.9 (90% of original length preserved)

---

## 12.3 Implementation Benchmarks

Implementation benchmarks test the code generation pipeline.

### Purpose

Verify that:
- Implementation planning works correctly
- Code generation prompts are effective
- Multi-file parsing works
- File path validation is correct
- Generated code structure is reasonable

### Running Implementation Benchmarks

**Automated**:
```bash
python3 auto_master.py benchmark_impl
```

**Success Criteria**:
✅ Implementation plan can be generated
✅ Prompts are built correctly with role context
✅ AI responses contain valid `<<<CODE_FILE_START>>>` markers
✅ File paths are validated and within allowed directories
✅ Generated code has proper structure and markers

---

## 12.4 Qualitative Evaluation

Beyond automated metrics, qualitative evaluation assesses the actual quality and usefulness of generated content.

### PRD Quality Assessment

**Clarity & Completeness**: Are requirements clear? Are all major sections covered? Is the level of detail appropriate?

**Consistency**: Do role-based enhancements align with their expertise? Are terminology and concepts used consistently?

**Usefulness**: Can the PRD guide actual implementation? Are implementation mappings clear?

### Code Quality Assessment

**Structure**: Is code organized logically? Are files in appropriate directories?

**Readability**: Is code well-commented? Are naming conventions followed?

**Completeness**: Are imports and dependencies included? Is error handling present?

---

## 12.5 Meta-Improvement & Evolution

This automation system can improve itself through a structured meta-improvement process.

### Meta-Improvement Process

1. **Identify Improvement Opportunity**: Something fails or behaves suboptimally
2. **Document the Issue**: Capture in "Automation Evolution Log"
3. **Design the Improvement**: Propose change, ensure backward compatibility
4. **Implement in Dedicated Phase**: Use special Phase prefix: `AUTO-IMPROVE-X.Y`
5. **Validate**: Run `smoke_test` and benchmarks
6. **Document**: Update Evolution Log and relevant sections

### Automation Evolution Log Template

| Phase ID | Date | Improvement | Rationale | Status |
|----------|------|-------------|-----------|--------|
| AUTO-IMPROVE-1.1 | 2025-XX-XX | Added smoke_test command | Need quick verification | ✅ Complete |

**Legend**: ✅ Complete | 🔄 In Progress | 📋 Planned | ❌ Rejected

### Guidelines for Meta-Improvements

- **Small & Incremental**: Make one focused change at a time
- **Backward Compatible**: Don't break existing configs
- **Well-Tested**: Always run smoke tests and benchmarks
- **Well-Documented**: Update `prd.md` sections and Evolution Log

<!-- EVAL_SECTION_END -->

---

# 13. OPEN-SOURCE GOVERNANCE & CONTRIBUTION GUIDE

This section defines how this automation system is governed, versioned, extended, and contributed to. It establishes clear boundaries between the stable core and user extensions, ensuring the system remains reliable and maintainable as an open-source template.

<!-- GOVERNANCE_SECTION_START -->

## 13.1 Core vs Extension Zones (Architecture of Responsibility)

This system is organized into distinct layers with different rules for modification and contribution.

### CORE AUTOMATION LAYER

**Files**: `auto_master.py`, `auto_config.json`, `cursor_driver.scpt`, `auto_master.sh`, `.auto_state.json` (runtime), `auto_master.log` (runtime)

**Rules**:
- Changes to these files affect **all users** of the template
- Must maintain backward compatibility where possible
- Breaking changes require MAJOR version bump
- All changes must pass `smoke_test` and relevant benchmarks

### CORE SPEC LAYER

**Content in `prd.md`**: Omni-Corp Role Library, Prompt Library, Phase & Task Framework, Meta-Orchestrator Instructions, Evaluation & Benchmarks, Governance section

**Rules**:
- Changes here affect how AI agents behave for **all** projects using this template
- Breaking changes to Meta-Orchestrator instructions require MAJOR version bump
- New roles, prompts, or templates can be added as MINOR version features

### PROJECT-SPECIFIC LAYER

**Content**: Project-specific PRD content, application code under `project_root`

**Rules**:
- Users can change these freely without affecting the template
- Not subject to template versioning
- Can be customized for any project type

### EXTENSION LAYER

**Optional User-Defined**: Additional Python scripts, extra documentation, custom build scripts, project-specific automation helpers

**Rules**:
- Must not modify or override core behaviors unless clearly opt-in
- Should be documented in `prd.md` under "Extensions" subsection
- Can be shared as examples but are not part of the core template

---

## 13.2 Versioning & Release Semantics

This template uses **Semantic Versioning** (SemVer): **MAJOR.MINOR.PATCH**

- **MAJOR** (X.0.0): Breaking changes to core automation or spec
- **MINOR** (X.Y.0): New features, backwards compatible
- **PATCH** (X.Y.Z): Bug fixes, internal improvements

### Version Storage

**In `auto_master.py`**:
```python
TEMPLATE_VERSION = "1.0.0"
```

**In `prd.md`**: Recorded in "Template Version & Changelog" subsection

**In `auto_config.json`** (optional):
```json
{
  "_template_version": "1.0.0",
  "_template_compatible_from": "1.0.0"
}
```

### Release Process

1. **Pre-Release Validation**: Run `smoke_test`, `benchmark_growth`, `benchmark_impl`
2. **Version Update**: Update `TEMPLATE_VERSION` in `auto_master.py` and changelog in `prd.md`
3. **Changelog Entry**: Add entry with version, date, changes (grouped by MAJOR/MINOR/PATCH)
4. **Git Tagging**: `git tag -a v1.0.0 -m "Release v1.0.0"`
5. **Release Notes**: Create GitHub release with summary and migration notes

### Template Version & Changelog

| Version | Date | Type | Changes |
|---------|------|------|---------|
| 1.0.0 | 2025-XX-XX | Initial | Initial stable release with full automation pipeline |

**Current Version**: 1.0.0

---

## 13.3 Contribution Workflow & Guidelines

### How to Contribute

1. **Fork the Repository**: Create your own fork and clone locally
2. **Create a Feature Branch**: `git checkout -b feature/your-feature-name`
3. **Make Changes**: Core changes, spec changes, documentation, or extensions
4. **Test Your Changes**: Run `smoke_test`, `benchmark_growth`, `benchmark_impl`
5. **Update Documentation**: Update relevant sections in `prd.md` and `README.md`
6. **Submit a Pull Request**: Include description, impact, testing, and type

### Review Guidelines

**What Gets Reviewed**:
- ✅ All changes to core commands
- ✅ Config schema changes
- ✅ Meta-Orchestrator instruction changes
- ✅ New roles, prompts, or templates
- ✅ Breaking changes (MAJOR version)

**Review Criteria**:
- Backward Compatibility: Does this break existing configs or workflows?
- Safety: Does this maintain safety guarantees?
- Testing: Have appropriate tests been run?
- Documentation: Is the change documented?
- Clarity: Is the code/change clear and maintainable?

**Encouraged Practices**:
- ✅ Small, atomic PRs (one feature or fix per PR)
- ✅ Clear commit messages
- ✅ Tests for core changes
- ✅ Documentation updates

**Discouraged Practices**:
- ❌ Large, multi-feature PRs
- ❌ Breaking changes without migration notes
- ❌ Changes that reduce safety or universality
- ❌ Project-specific code in core files

---

## 13.4 Extensions & Customization Patterns

### Custom Roles

**Pattern**: Add new roles under a separate subsection in `prd.md` (e.g., "Project-Specific Roles")

**Guidelines**:
- ✅ Add to project-specific section
- ✅ Follow existing role template structure
- ✅ Document clearly
- ❌ Don't modify core role library structure

### Custom Prompts

**Pattern**: Add project-specific prompts under "Project-Specific Prompt Library" (Section 8.X)

**Guidelines**:
- ✅ Add to project-specific section
- ✅ Reference project-specific roles if needed
- ✅ Keep core templates intact

### Custom Implementation Logic

**Pattern**: Create separate scripts in `tools/` or `scripts/` directory, use `auto_master.py` as a library or call it via CLI

**Guidelines**:
- ✅ Create separate files/directories
- ✅ Use `auto_master.py` CLI or import as library
- ✅ Document your extensions
- ❌ Don't modify `auto_master.py` for project-specific needs

### Custom Profiles

**Pattern**: Extend `profiles.profiles` in `auto_config.json`, document new profiles in `prd.md`

**Guidelines**:
- ✅ Add to `auto_config.json` `profiles.profiles`
- ✅ Document in `prd.md`
- ✅ Use descriptive names
- ❌ Don't remove or rename existing profiles

<!-- GOVERNANCE_SECTION_END -->

---

# 14. APP FACTORY MODE & MULTI-PROJECT USAGE

This section describes how to use this template as an "App Factory" to manage multiple independent projects, each with its own repository and PRD automation.

<!-- APP_FACTORY_SECTION_START -->

## 14.1 App Factory Concept

**App Factory Pattern**: A pattern where one developer or team can spin up many independent projects (each with its own repo and PRD automation), using this template.

**Key Principles**:
- Each app or system lives in its own repo using this template
- One template → many derived repos
- Each derived repo has: its own `prd.md`, `auto_master.py`, `auto_config.json`, `.auto_state.json`, `auto_master.log`, git history and remote
- Master Controller exists *outside* this repo (AI agent, human + scripts, CI pipeline)

## 14.2 Standard Multi-Project Workflows

### Workflow 1: Create a New App Project from Template

1. Create new repo from template (GitHub "Use this template" or `git clone` & `git remote`)
2. Set repo name (e.g., `xyz-app`)
3. In new repo: Open `prd.md`, insert app description, run `python3 auto_master.py init`, `sync_roles`, `grow`
4. Summarize: Where the new repo is, how to continue work

### Workflow 2: Maintain N Projects in Parallel

1. Maintain list of active project repos (paths or remote URLs)
2. For each project: `cd` into repo, run `doctor`, `status --verbose`, optionally `grow`
3. When user requests "regrow all PRDs": Loop over each repo and run `grow`
4. When user requests "implement top tasks on project X": Focus on project X, run `plan_impl` / `impl_loop`

### Workflow 3: Archive / Freeze a Project

1. Run final `doctor`, `status`, `git_status`
2. Tag a release (e.g., `v1.0.0-app-X`)
3. Mark in `prd.md` a "Project Completed / Archived" note
4. Master Controller can keep repo listed as "archived" but not run `grow` or `impl_loop` on it

## 14.3 Conventions for Naming & Paths

**Repo Naming**: Template repo (e.g., `prd-auto-template`), Project repos (e.g., `app-<project-name>`, `game-<project-name>`)

**Directory Layout**: One app per repo; app source code lives under `project_root` (as configured in `auto_config.json`)

**Config Customization**: After creating new repo, edit `auto_config.json`: `master_md_path`, `implementation` settings, `profiles.default_profile`

## 14.4 Master Control Pattern

**Master Controller** is an external entity (AI agent, human, CI pipeline) that:
- Creates new repos from template
- Applies Meta-Orchestrator Start Prompt to each repo
- Runs `start` for each project
- Monitors health across multiple projects (via `doctor`, `status`)

**Important**: Master Controller exists *outside* this repo, not as code in this repo.

## 14.5 Template Upgrade / Migration Across Many Projects

**Template Upgrade Playbook**:
1. For each project repo: Create branch `template-upgrade-v1.1.0`
2. Compare: `auto_master.py`, `auto_config.json`, `cursor_driver.scpt`, `.gitignore`, `LICENSE`, `README.md`
3. Merge or reapply template changes carefully (use diff tools, avoid overwriting project-specific config)
4. Run: `doctor`, `smoke_test`, `benchmark_*`
5. If everything passes, merge branch into main and tag release

**Note**: `prd.md` is part core, part project-specific. Keep core sections aligned with latest template, keep project-specific sections intact.

<!-- APP_FACTORY_SECTION_END -->

---

# 15. DOMAIN PACKS & PRESETS

This section describes Domain Packs and Presets – reusable bundles of roles, prompts, phase patterns, and implementation hints tailored to different kinds of projects.

<!-- DOMAIN_PACKS_SECTION_START -->

## 15.1 What Are Domain Packs?

A **Domain Pack** is a predefined bundle of:
- **Recommended Roles**: Subset of Omni-Corp roles best suited for this domain
- **Suggested Tech Stack**: Languages, frameworks, and tools commonly used
- **Phase Patterns**: Common phase patterns and task structures
- **Implementation Tracks**: Prioritized implementation tracks (Client, Backend, AI, etc.)

**Important**: Domain Packs are **guidance, not strict constraints**. You can override any pack suggestion, mix and match elements, create custom packs, or change stack/roles at any time.

## 15.2 Available Domain Packs

The following Domain Packs are available in `auto_config.json`:

### generic_app
**Best For**: General-purpose apps when domain is unclear. **Primary Target**: Multi-platform. **Suggested Stack**: React Native/Flutter (mobile), React/Next.js (web), Node.js/Python (backend)

### mobile_app
**Best For**: Mobile-first apps (iOS/Android). **Primary Target**: Mobile. **Suggested Stack**: React Native or Flutter. **Phase Patterns**: MVP_CORE, AUTH, PUSH_NOTIFICATIONS, OFFLINE_MODE

### web_app
**Best For**: Web-first apps or SaaS dashboards. **Primary Target**: Web. **Suggested Stack**: Next.js or React. **Phase Patterns**: MVP_CORE, AUTH, ANALYTICS, BILLING, SEO

### game_2d
**Best For**: 2D games with core loop, levels, monetization. **Primary Target**: Game. **Suggested Stack**: Unity or Godot. **Phase Patterns**: CORE_LOOP, LEVELS, UI, MONETIZATION

### ai_tool
**Best For**: AI-powered assistant, generator, or automation tool. **Primary Target**: AI Tool. **Suggested Stack**: Python/FastAPI or Node.js. **Phase Patterns**: MVP_CORE, AI_INTEGRATION, SAFETY_GUARDS, LOGGING

### backend_service
**Best For**: Backend API service or microservice. **Primary Target**: Backend. **Suggested Stack**: Python/FastAPI, Node.js/Express, or Go. **Phase Patterns**: MVP_CORE, API_DESIGN, AUTH, DATABASE

### data_app
**Best For**: Data analysis, visualization, or business intelligence. **Primary Target**: Multi-platform. **Suggested Stack**: React/Next.js or Python/Dash. **Phase Patterns**: MVP_CORE, DATA_INGESTION, ANALYTICS, VISUALIZATION

## 15.3 Domain Pack Template

To create a custom Domain Pack:
- **Pack ID**: [e.g., "ecommerce_web"]
- **Description**: [what kind of projects this suits]
- **Primary Target Type**: [mobile/web/game/backend/ai_tool/multi]
- **Suggested Roles**: [subset of Omni-Corp roles]
- **Suggested Stack**: [languages, frameworks, engines]
- **Default Phase Patterns**: [labels like MVP_CORE, AUTH, CHECKOUT]
- **Default Implementation Tracks**: [Client, Backend, Data, AI, Infra]

## 15.4 Presets (Domain + Stack + Style)

A **Preset** combines: Domain Pack + Implementation settings + Style tags

**Example Presets**:
- `mobile_todo_react_native`: Domain Pack `mobile_app`, React Native + TypeScript, style tags: ["offline_friendly", "minimal_ui"]
- `web_saas_dashboard_nextjs`: Domain Pack `web_app`, Next.js + TypeScript, style tags: ["multi_tenant", "metrics_first", "b2b"]

## 15.5 Using Domain Packs

**Automatic Selection**: When you describe your app to Meta-Orchestrator and type `start`, it will:
1. Parse your description for domain keywords
2. Match to a Domain Pack
3. Apply pack defaults (set `domain_packs.default_pack`, configure `implementation.*`)
4. Respect your overrides (if you specify framework, use that instead)

**Manual Selection**: Edit `auto_config.json` and set `domain_packs.default_pack = "mobile_app"` or tell the AI agent

<!-- DOMAIN_PACKS_SECTION_END -->

---

# 16. DEPLOYMENT, ENVIRONMENTS & RUNTIME MONITORING

This section describes how to configure and use deployment, environment management, and runtime monitoring as part of the full application lifecycle.

<!-- DEPLOYMENT_SECTION_START -->

## 16.1 High-Level Deployment Model

This template provides a **generic deployment model** that can be adapted to any cloud provider, CI/CD system, or deployment platform.

**Core Principles**:
- **Cloud/Platform Neutral**: No hard dependencies on specific providers
- **CI/CD Agnostic**: Works with GitHub Actions, GitLab CI, CircleCI, or custom scripts
- **Safety First**: No destructive actions by default, requires explicit approval for production
- **Hook-Based**: Defines commands and templates that external systems can execute

### Environment Types

**Local**: Developer's machine, rapid iteration, no remote deployment

**Preview**: Per-branch or per-PR builds, temporary, manual QA

**Staging**: Shared pre-production environment, near-real production setup, requires approval

**Production**: Real users and real data, highest reliability requirements, requires approval and monitoring

## 16.2 Deployment Hooks

Deployment hooks are generic commands defined in `auto_config.json`:

- **build_command**: Command to build/compile (e.g., `npm run build`)
- **test_command**: Command to run tests (e.g., `npm test`)
- **lint_command**: Command to run linters (e.g., `npm run lint`)
- **deploy_command_template**: Template for deploy command (use `{env}` placeholder)
- **rollback_command_template**: Template for rollback command (optional)
- **health_check_command**: Command to verify deployment health (optional)

## 16.3 Monitoring & Feedback

**Monitoring Configuration**:
- **Log Sources**: `auto_master.log`, application logs, CI/CD logs
- **Alert Policy**: `manual_review`, `basic_thresholds`, or `external_system`
- **Basic Thresholds**: `max_error_rate_percent`, `max_failed_deploys`, `min_deploy_interval_minutes`

**Monitoring Workflow**:
1. Collect logs from configured sources
2. Analyze error patterns and calculate error rates
3. Compare against thresholds and generate alerts if needed
4. Report human-readable summary with recommendations

## 16.4 Deployment Best Practices

**Pre-Deployment Checklist**:
- [ ] Run `python3 auto_master.py doctor`
- [ ] Run `python3 auto_master.py smoke_test`
- [ ] Review git changes
- [ ] Run tests and linters locally
- [ ] Test build locally
- [ ] Review deployment plan (dry-run)

**Deployment Process**:
1. Prepare: Ensure all tests pass, review changes, get approvals
2. Build: Execute `build_command`
3. Test: Execute `test_command`
4. Deploy: Execute `deploy_command_template` with environment
5. Verify: Execute `health_check_command` if available
6. Monitor: Watch logs for errors, be ready to rollback

## 16.5 CI/CD Integration

This template is designed to work with any CI/CD system. CI/CD systems can:
- Read hooks from `auto_config.json`
- Execute hooks as part of pipeline
- Substitute environment variables and secrets
- Report results

**Example**: GitHub Actions can read `deployment.deploy_hooks.build_command` from `auto_config.json` and execute it in workflow.

## 16.6 Cloud Provider Adaptation

The deployment model is cloud/provider neutral. Adapt `deploy_command_template` for your provider:
- **AWS**: S3 sync, CloudFront, ECS, etc.
- **GCP**: App Engine, Cloud Run, GKE, etc.
- **Azure**: App Service, Container Instances, AKS, etc.
- **Vercel/Netlify**: Platform-specific CLI commands
- **Mobile Stores**: Fastlane, app store APIs

<!-- DEPLOYMENT_SECTION_END -->

---

# 17. SECURITY, PRIVACY, COMPLIANCE & TESTING

This section establishes security, privacy, compliance, and testing foundations for the application.

<!-- SECURITY_SECTION_START -->

## 17.1 Security Architecture Overview

**Security Principles**:
- **Least Privilege**: Users and systems should have only minimum permissions necessary
- **Defense in Depth**: Multiple layers of security controls
- **Secure Defaults**: Default configurations should be secure
- **Security by Design**: Consider security in architecture decisions
- **Privacy by Design**: Minimize data collection, encrypt sensitive data

### Security Checklist Template

**Authentication & Authorization**: [ ] Authentication required for sensitive actions, [ ] Strong password policy, [ ] Role-based authorization defined

**Input Validation & Output Encoding**: [ ] All inputs validated and sanitized, [ ] SQL injection prevention, [ ] XSS prevention

**Rate Limiting & Abuse Prevention**: [ ] Rate limiting on endpoints, [ ] Account lockout after failed attempts

**Secure Storage**: [ ] Secrets in secure locations, [ ] No secrets in code/logs, [ ] Passwords hashed with strong algorithms

**Transport Security**: [ ] HTTPS enforced in production, [ ] TLS 1.2+ required

**Logging & Monitoring**: [ ] Security events logged, [ ] No sensitive data in logs

## 17.2 Privacy & Data Classification

### Data Classification Levels

- **Public**: Information intended for public consumption
- **Internal**: Information for internal use only
- **Sensitive**: Information that could cause harm if exposed (email, phone, location, payment)
- **Restricted**: Highly sensitive information requiring strict controls (passwords, health records, financial account numbers)

### Data Classification Template

For each data type, document:
- **Classification Level**: [public/internal/sensitive/restricted]
- **Storage Location(s)**: [Database tables, third-party services]
- **Retention Period**: [Days/months/years]
- **Access Roles**: [Which roles/systems can access]
- **Encryption**: [At rest: yes/no, In transit: yes/no]

### Privacy Principles

- **Data Minimization**: Collect only data necessary
- **Purpose Limitation**: Use data only for stated purpose
- **Storage Limitation**: Retain data only as long as necessary
- **Accuracy**: Keep data accurate and up to date
- **Security**: Protect data with appropriate measures
- **Transparency**: Inform users about data collection and use

## 17.3 Compliance & Legal Considerations

### Common Compliance Regimes

- **GDPR**: EU users, consent, data subject rights, breach notification
- **CCPA**: California residents, disclosure, opt-out rights
- **HIPAA**: Healthcare data, PHI safeguards
- **PCI DSS**: Credit card data, secure cardholder environment
- **COPPA**: Children's data, parental consent
- **App Store Policies**: Privacy policy, data use disclosure

### Compliance Checklist

- [ ] Identify target user jurisdictions
- [ ] Identify applicable compliance regimes
- [ ] Privacy policy exists and is accessible
- [ ] Data subject rights handling process defined
- [ ] Data retention and deletion policies implemented
- [ ] Third-party data sharing documented

**Legal Disclaimer**: This section provides general guidance and checklists. It is not legal advice. Consult qualified legal counsel for compliance matters.

## 17.4 Testing Strategy

### Testing Levels

- **Unit Tests**: Fast, isolated tests for individual components (70%+ coverage target)
- **Integration Tests**: Tests for component interactions and APIs
- **End-to-End Tests**: Complete user workflow tests
- **Security Tests**: Static analysis, dependency scanning, DAST, penetration testing
- **Performance Tests**: Load testing, stress testing, benchmarking

### Testing Strategy Template

Document your testing approach:
- **Unit Tests**: Framework, scope, coverage target, command, frequency
- **Integration Tests**: Framework, scope, command, frequency
- **End-to-End Tests**: Framework, scope, command, frequency
- **Security Tests**: Tools, frequency
- **Performance Tests**: Tool, scenarios, metrics, frequency

## 17.5 Incident Response & Evolution

### Incident Response Process

1. **Detection**: Monitor logs, use automated alerts
2. **Assessment**: Determine scope and severity
3. **Containment**: Isolate affected systems
4. **Eradication**: Remove malware or backdoors
5. **Recovery**: Restore systems from backups
6. **Post-Incident**: Document, conduct post-mortem, implement improvements

### Incident Documentation Template

When recording incidents:
- **Date/Time**: When did it occur?
- **Severity**: [Low/Medium/High/Critical]
- **Type**: [Data breach, DDoS, unauthorized access, etc.]
- **Affected Systems**: Which systems were impacted?
- **Response**: Immediate actions taken
- **Root Cause**: What caused the incident?
- **Remediation**: Immediate fixes and long-term improvements

<!-- SECURITY_SECTION_END -->
